//! Tokioタスクは非同期いグリーンスレッドである。
//!
//! `グリーンスレッド`
//! グリーンスレッドとは、OSの代わりに、ランタイムライブラリや仮想マシンなどによって
//! スケジュールされるスレッドを示す。
//!
//! Tokioタスクは`tokio::spawn`に`async`ブロックを渡すことによって作成される。
//! `tokio::spawn`関数は`JoinHandle`を返却して、`JoinHandle`は、呼び出し者が
//! 生成されたタスクと相互作用するために使用される。呼び出し者は`JoinHandle`に対して
//! `.await`を使用することで、戻り値を得ることができる。
//!
//! `JoinHandle`に対して`.await`することで`Result`が返却される。
//! タスクは実行中にエラーに遭遇したとき、`JoinHandle`は`Err`を返却する。
//! これは、パニックまたはタスクがランタイムの停止によって強制的にキャンセルされた場合の
//! どちらでも発生する。
//!
//! タスクはスケジューラーによって管理された実行単位である。
//! タスクを生成することは、Tokioスケジューラにタスクを提出することで、その後、
//! スケジューラーはタスクにするべき作業を持っているとき、タスクが実行することを保証する。
//! 生成されたタスクは、タスクが生成した同じスレッドで実行されるかもしれないし、
//! また異なるランタイムスレッドで実行されるかもしれない。
//! また、タスクが生成された後で、タスクはスレッド間を移動することができる。
//!
//! Tokioにおける`Task`はとても軽量である。
//! その仕組みの基で、`Task`は1回の領域確保と64バイトのメモリのみを要求する。
//! アプリケーションは、数百万個のは無理でも、数千個のタスクを自由に生成できる。
#[tokio::main]
async fn main() {
    let handle = tokio::spawn(async {
        // 任意の非同期作業を実施する。
        "return value"
    });

    // 任意の他の作業を実施する。

    let out = handle.await.unwrap();
    println!("獲得: {}", out);
}
